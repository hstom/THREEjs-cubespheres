<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="./three.js"></script>

<script>
    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    { // SETUP CAMERA
        camera.position.x = 3.9;
        camera.position.y = 0;
        camera.position.z = 24;
        camera.up = new THREE.Vector3(1, 0, 0);
    }

    var renderer = new THREE.WebGLRenderer();
    { // SETUP RENDERER
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        { // SETUP RENDERER SHADOW MAPPING
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
    }

    var cubeMaterial = new THREE.MeshPhongMaterial({
        color: 0x888888,
        shininess: 3,
        specular: 0xbbbbbb,
        emissive: 0x080808,
        opacity: 1,
        transparent: true
    });

    const CUBE_WIDTH = 3;

    var rootCube = new THREE.Mesh(
        new THREE.BoxGeometry(CUBE_WIDTH, CUBE_WIDTH, CUBE_WIDTH),
        cubeMaterial
    );
    rootCube.castShadow = true;
    rootCube.receiveShadow = true;

    { // SETUP SUB CUBES AND ATTACHE TO ROOT CUBE
        var subCubes = [];
        var buildSubCube = (attachmentPoint, edgeLength, differential, aggregator) => {
            var subGeo = new THREE.BoxGeometry(edgeLength, edgeLength, edgeLength);
            var subCube = new THREE.Mesh(subGeo, cubeMaterial);
            subCube.castShadow = true;
            subCube.receiveShadow = true;
            differential(subCube);
            attachmentPoint.add(subCube);
            aggregator.push(subCube);
        };

        let subCubeWidth = CUBE_WIDTH / 3;
        let subCubeOffset = CUBE_WIDTH / 2 + 3 * subCubeWidth / 2;

        buildSubCube(rootCube, subCubeWidth, sc => sc.position.x = subCubeOffset, subCubes);
        buildSubCube(rootCube, subCubeWidth, sc => sc.position.x = -subCubeOffset, subCubes);

        buildSubCube(rootCube, subCubeWidth, sc => sc.position.y = subCubeOffset, subCubes);
        buildSubCube(rootCube, subCubeWidth, sc => sc.position.y = -subCubeOffset, subCubes);

        buildSubCube(rootCube, subCubeWidth, sc => sc.position.z = subCubeOffset, subCubes);
        buildSubCube(rootCube, subCubeWidth, sc => sc.position.z = -subCubeOffset, subCubes);

        let lastCubeWidth = subCubeWidth;
        subCubeWidth = lastCubeWidth / 3;
        subCubeOffset = lastCubeWidth / 2 + 3 * subCubeWidth / 2;

        var subsubCubes = [];
        subCubes.map(sc => {
            buildSubCube(sc, subCubeWidth, ssc => ssc.position.x = subCubeOffset, subsubCubes);
            buildSubCube(sc, subCubeWidth, ssc => ssc.position.x = -subCubeOffset, subsubCubes);

            buildSubCube(sc, subCubeWidth, ssc => ssc.position.y = subCubeOffset, subsubCubes);
            buildSubCube(sc, subCubeWidth, ssc => ssc.position.y = -subCubeOffset, subsubCubes);

            buildSubCube(sc, subCubeWidth, ssc => ssc.position.z = subCubeOffset, subsubCubes);
            buildSubCube(sc, subCubeWidth, ssc => ssc.position.z = -subCubeOffset, subsubCubes);
        });
        lastCubeWidth = subCubeWidth;
        subCubeWidth = lastCubeWidth / 3;
        subCubeOffset = lastCubeWidth / 2 + 3 * subCubeWidth / 2;
        subsubCubes.map(ssc => {
            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.x = subCubeOffset, []);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.x = -subCubeOffset, []);

            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.y = subCubeOffset, []);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.y = -subCubeOffset, []);

            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.z = subCubeOffset, []);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.position.z = -subCubeOffset, []);
        })
    }
    scene.add(rootCube);

    {// ADD FLOOR (actually a globe heh)
        var galacticFloorGeom = new THREE.PlaneBufferGeometry(10000, 10000, 2, 2);
        var galacticFloorMat = new THREE.MeshPhongMaterial(
            { color: 0xaaaaff, shininess: 20 }
        );
        var plane = new THREE.Mesh(galacticFloorGeom, galacticFloorMat);
        plane.position.x = -8;
        plane.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);

        plane.receiveShadow = true;
        scene.add(plane);

        var galacticFirmamentGeom = new THREE.SphereBufferGeometry(20, 80, 80);
        var galacticFirmamentMat = new THREE.MeshPhongMaterial(
            { color: 0xaaaaff, shininess: 20 }
        );
        galacticFirmamentMat.side = THREE.BackSide;
        var firmament = new THREE.Mesh(galacticFirmamentGeom, galacticFirmamentMat);

        firmament.receiveShadow = true;
        scene.add(firmament);
    }

    var particleLights = [];
    {// LIGTHING
        scene.add(new THREE.AmbientLight(0x020804));

        var hemiLight = new THREE.HemisphereLight(
            0xaaaaaa,
            0x444444,
            .4
        );
        scene.add(hemiLight);

        const genAndAddParticleLight = (color, position, surfColor = color) => {
            var particleLight = new THREE.Mesh(
                new THREE.SphereBufferGeometry(.08, 12, 12),
                new THREE.MeshBasicMaterial({ color: surfColor })
            );

            var pointLight = new THREE.PointLight(color, 2, 480000);
            pointLight.castShadow = true;

            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.camera.near = 0.5;
            pointLight.shadow.camera.far = 500;

            particleLight.add(pointLight);

            Object.assign(particleLight.position, position);
            scene.add(particleLight);
            particleLights.push(particleLight);
        };

        genAndAddParticleLight(0xff0000, { x: 5 }, 0xff4444);
        genAndAddParticleLight(0x00ff00, { y: 5 }, 0x44ff44);
        genAndAddParticleLight(0x0000ff, { z: 5 }, 0x4444ff);
    }

    //sloopy quat
    var lQuat = new THREE.Quaternion();
    lQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 1), Math.PI / 8400).normalize();

    function animate() {
        requestAnimationFrame(animate);

        var dynamicQuaternion = new THREE.Quaternion();
        dynamicQuaternion.setFromAxisAngle(particleLights[0].position.clone().sub(rootCube.position), Math.PI / 1024).normalize();

        var quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(new THREE.Vector3(1, -1, 0), Math.PI / 512).normalize();
        rootCube.applyQuaternion(dynamicQuaternion);
        rootCube.applyQuaternion(quaternion);
        rootCube.applyQuaternion(lQuat);

        particleLights.map((pl) => pl.position.applyQuaternion(lQuat));

        var cQuat = new THREE.Quaternion();
        cQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 300);

        camera.position.applyQuaternion(cQuat);
        camera.lookAt(rootCube.position);


        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>
