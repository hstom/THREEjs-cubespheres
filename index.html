<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>[LEFT] [UP] [RIGHT] [DOWN]</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<script src="./three.js"></script>

<script>
    var UP = false;
    var DOWN = false;
    var LEFT = false;
    var RIGHT = false;

    var leftKeys = ["37", "65"];
    var upKeys = ["38", "87"];
    var rightKeys = ["39", "68"];
    var downKeys = ["40", "83"];

    var keyHandlerBlob = {};

    [
        [(val) => LEFT = val, leftKeys],
        [(val) => UP = val, upKeys],
        [(val) => RIGHT = val, rightKeys],
        [(val) => DOWN = val, downKeys]
    ]
        .forEach(
            ([stateVarUpdater, keyCodes]) => {
                keyCodes.forEach(
                    keyCode => {
                        keyHandlerBlob[keyCode] = {
                            state: false,
                            updater: () => {
                                stateVarUpdater(keyCodes.map(kc => keyHandlerBlob[kc].state).reduce((acc, val) => acc || val, false));
                            }
                        }
                    }
                )
            }
        );

    document.addEventListener('keydown', function(e) {
        Object.keys(keyHandlerBlob).some(
            kc => {
                if(""+e.which === kc) {
                    keyHandlerBlob[kc].state = true;
                    keyHandlerBlob[kc].updater();
                    return true;
                }
                return false;
            }
        )
    });

    document.addEventListener('keyup', function(e) {
        Object.keys(keyHandlerBlob).some(
            kc => {
                if(""+e.which === kc) {
                    keyHandlerBlob[kc].state = false;
                    keyHandlerBlob[kc].updater();
                    return true;
                }
                return false;
            }
        )
    });

    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    { // SETUP CAMERA
        camera.position.x = 3.9;
        camera.position.y = 12;
        camera.position.z = 20;
        camera.up = new THREE.Vector3(1, 0, 0);
    }

    var renderer = new THREE.WebGLRenderer();
    { // SETUP RENDERER
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        { // SETUP RENDERER SHADOW MAPPING
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
    }

    var cubeMaterial = new THREE.MeshPhongMaterial({
        color: 0x888888,
        shininess: 3,
        specular: 0xbbbbbb,
        emissive: 0x080808,
        opacity: 1,
        transparent: true
    });

    const CUBE_WIDTH = 3;

    var rootCube = new THREE.Mesh(
        new THREE.BoxGeometry(CUBE_WIDTH, CUBE_WIDTH, CUBE_WIDTH),
        cubeMaterial
    );
    rootCube.castShadow = true;
    rootCube.receiveShadow = true;


    var ALL_SUB_CUBES = [];
    { // SETUP SUB CUBES AND ATTACH TO ROOT CUBE
        var subCubes = [];
        var buildSubCube = (attachmentPoint, edgeLength, differential, aggregator, originalOffset) => {
            var subGeo = new THREE.BoxGeometry(edgeLength, edgeLength, edgeLength);
            var subCube = new THREE.Mesh(subGeo, cubeMaterial);
            subCube.ORIGINAL_OFFSET = originalOffset;
            subCube.castShadow = true;
            subCube.receiveShadow = true;
            differential(subCube.position);
            subCube.ORIGINAL_POSITION = new THREE.Vector3();
            differential(subCube.ORIGINAL_POSITION);
            attachmentPoint.add(subCube);
            ALL_SUB_CUBES.push(subCube);
            aggregator.push(subCube);
        };

        let subCubeWidth = CUBE_WIDTH / 3;
        let subCubeOffset = CUBE_WIDTH / 2 + 3 * subCubeWidth / 2;

        buildSubCube(rootCube, subCubeWidth, sc => sc.x = subCubeOffset, subCubes, subCubeOffset);
        buildSubCube(rootCube, subCubeWidth, sc => sc.x = -subCubeOffset, subCubes, subCubeOffset);

        buildSubCube(rootCube, subCubeWidth, sc => sc.y = subCubeOffset, subCubes, subCubeOffset);
        buildSubCube(rootCube, subCubeWidth, sc => sc.y = -subCubeOffset, subCubes, subCubeOffset);

        buildSubCube(rootCube, subCubeWidth, sc => sc.z = subCubeOffset, subCubes, subCubeOffset);
        buildSubCube(rootCube, subCubeWidth, sc => sc.z = -subCubeOffset, subCubes, subCubeOffset);

        let lastCubeWidth = subCubeWidth;
        subCubeWidth = lastCubeWidth / 3;
        subCubeOffset = lastCubeWidth / 2 + 3 * subCubeWidth / 2;

        var subsubCubes = [];
        subCubes.map(sc => {
            buildSubCube(sc, subCubeWidth, ssc => ssc.x = subCubeOffset, subsubCubes, subCubeOffset);
            buildSubCube(sc, subCubeWidth, ssc => ssc.x = -subCubeOffset, subsubCubes, subCubeOffset);

            buildSubCube(sc, subCubeWidth, ssc => ssc.y = subCubeOffset, subsubCubes, subCubeOffset);
            buildSubCube(sc, subCubeWidth, ssc => ssc.y = -subCubeOffset, subsubCubes, subCubeOffset);

            buildSubCube(sc, subCubeWidth, ssc => ssc.z = subCubeOffset, subsubCubes, subCubeOffset);
            buildSubCube(sc, subCubeWidth, ssc => ssc.z = -subCubeOffset, subsubCubes, subCubeOffset);
        });
        lastCubeWidth = subCubeWidth;
        subCubeWidth = lastCubeWidth / 3;
        subCubeOffset = lastCubeWidth / 2 + 3 * subCubeWidth / 2;
        subsubCubes.map(ssc => {
            buildSubCube(ssc, subCubeWidth, sssc => sssc.x = subCubeOffset, [], subCubeOffset);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.x = -subCubeOffset, [], subCubeOffset);

            buildSubCube(ssc, subCubeWidth, sssc => sssc.y = subCubeOffset, [], subCubeOffset);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.y = -subCubeOffset, [], subCubeOffset);

            buildSubCube(ssc, subCubeWidth, sssc => sssc.z = subCubeOffset, [], subCubeOffset);
            buildSubCube(ssc, subCubeWidth, sssc => sssc.z = -subCubeOffset, [], subCubeOffset);
        })
    }
    scene.add(rootCube);

    {// ADD FLOOR (actually a globe heh)
        var galacticFloorGeom = new THREE.PlaneBufferGeometry(10000, 10000, 2, 2);
        var galacticFloorMat = new THREE.MeshPhongMaterial(
            { color: 0xaaaaff, shininess: 20 }
        );
        var plane = new THREE.Mesh(galacticFloorGeom, galacticFloorMat);
        plane.position.x = -8;
        plane.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);

        plane.receiveShadow = true;
        scene.add(plane);

        var galacticFirmamentGeom = new THREE.SphereBufferGeometry(20, 80, 80);
        var galacticFirmamentMat = new THREE.MeshPhongMaterial(
            { color: 0xaaaaff, shininess: 20 }
        );
        galacticFirmamentMat.side = THREE.BackSide;
        var firmament = new THREE.Mesh(galacticFirmamentGeom, galacticFirmamentMat);

        firmament.receiveShadow = true;
        scene.add(firmament);
    }

    var particleLights = [];
    {// LIGHTING
        scene.add(new THREE.AmbientLight(0x020804));

        var hemiLight = new THREE.HemisphereLight(
            0xaaaaaa,
            0x444444,
            .4
        );
        scene.add(hemiLight);

        const genAndAddParticleLight = (color, position, surfColor = color) => {
            var particleLight = new THREE.Mesh(
                new THREE.SphereBufferGeometry(.08, 12, 12),
                new THREE.MeshBasicMaterial({ color: surfColor })
            );

            var pointLight = new THREE.PointLight(color, 2, 26);
            pointLight.castShadow = true;

            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.camera.near = 0.5;
            pointLight.shadow.camera.far = 500;

            particleLight.add(pointLight);

            Object.assign(particleLight.position, position);
            scene.add(particleLight);
            particleLights.push(particleLight);
        };

        genAndAddParticleLight(0xff0000, { x: 5 }, 0xff4444);
        genAndAddParticleLight(0x00ff00, { y: 5 }, 0x44ff44);
        genAndAddParticleLight(0x0000ff, { z: 5 }, 0x4444ff);
    }

    //sloopy quat
    var lQuat = new THREE.Quaternion();
    lQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 1), Math.PI / 1200).normalize();
    camera.lookAt(rootCube.position);

    function animate() {
        requestAnimationFrame(animate);



        particleLights.map((pl) => pl.position.applyQuaternion(lQuat));

        // var cQuat = new THREE.Quaternion();
        // cQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 300);

        // camera.position.applyQuaternion(cQuat);
        // camera.lookAt(rootCube.position);

        if(LEFT ^ RIGHT) {

            const sign = LEFT ? 1 : -1;

            // var dynamicQuaternion = new THREE.Quaternion();
            // dynamicQuaternion.setFromAxisAngle(particleLights[0].position.clone().sub(rootCube.position), sign * Math.PI / 1024).normalize();

            var quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle(new THREE.Vector3(1, -1, 0), sign * .05).normalize();
            // rootCube.applyQuaternion(dynamicQuaternion);
            rootCube.applyQuaternion(quaternion);
            // rootCube.applyQuaternion(lQuat);
        }

        if(UP ^ DOWN) {
            // var scalarScalor = 1 + ((UP * .0001) - (DOWN * .0001));
            //
            // console.log(scalarScalor);
            //
            // var scaleFactor = new THREE.Vector3(scalarScalor, scalarScalor, scalarScalor);

            ALL_SUB_CUBES.forEach(
                subCube => {
                    // TODO this doesn't really "reverse" properly
                    subCube.applyMatrix(
                        new THREE.Matrix4().compose(
                            new THREE.Vector3(0, 0, 0), // position
                            new THREE.Quaternion().setFromAxisAngle(
                                (
                                    UP
                                        ? subCube.ORIGINAL_POSITION.clone()
                                        : subCube.ORIGINAL_POSITION.clone().negate()
                                ).normalize()
                                ,
                                .05
                            ),
                            // scaleFactor
                            new THREE.Vector3(1, 1, 1)
                        )
                    );
                }
            );
        }


        renderer.render(scene, camera);


    }

    animate();
</script>
</body>
</html>
